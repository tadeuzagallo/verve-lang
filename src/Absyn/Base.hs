module Absyn.Base where

import Absyn.Meta
import Absyn.Type
import qualified Typing.Types as T

data BaseModule a = Module
  { imports :: [Import]
  , stmts :: [BaseStmt a]
  }

data BaseStmt a
  = Decl (BaseDecl a)
  | Expr (BaseExpr a)
  deriving (Show)

data BaseDecl a
  = FnStmt (BaseFunction a)
  | Enum String [String] [DataCtor]
  | Let (String, Maybe Type) (BaseExpr a)
  | Class { className :: String
          , classVars :: [Param]
          , classMethods :: [BaseFunction a]
          }
  | Operator { opAssoc :: Associativity
             , opPrec :: Precedence
             , opGenerics :: Generics
             , opLhs :: Param
             , opName :: String
             , opRhs :: Param
             , opRetType :: Type
             , opBody :: [BaseStmt a]
             }
  | Interface { intfName :: String
              , intfParam :: String
              , intfMethods :: [InterfaceItem]
              }
  | Implementation { implIntf :: a
                   , implGenerics :: Generics
                   , implType :: Type
                   , implMethods :: [BaseImplementationItem a]
                   }
  | TypeAlias { aliasName :: String
              , aliasVars :: [String]
              , aliasType :: Type
              , resolvedType :: Maybe T.Type
              }
   deriving (Show)

data InterfaceItem
  = IntfVar (String, Type)
  | IntfOperator { intfOpAssoc :: Associativity
                 , intfOpPrec :: Precedence
                 , intfOpLhs :: Type
                 , intfOpName :: String
                 , intfOpRhs :: Type
                 , intfOpRetType :: Type
                 }

  deriving (Show)

data BaseImplementationItem a
  = ImplVar (String, BaseExpr a)
  | ImplFunction { implName :: String
                 , implParams :: [String]
                 , implBody :: [BaseStmt a]
                 }
  | ImplOperator { implOpLhs :: String
                 , implOpName :: String
                 , implOpRhs :: String
                 , implOpBody :: [BaseStmt a]
                 }
 deriving (Show)

type DataCtor = (String, Maybe [Type])
type Param = (String, Type)
type Generics = [(String, [String])]

data BaseFunction a = Function
  { name :: String
  , generics :: Generics
  , params :: [Param]
  , retType :: Type
  , body :: [BaseStmt a]
  } deriving (Show)

data BaseExpr a
  = Literal Literal
  | Ident [String]
  | ParenthesizedExpr (BaseExpr a)
  | Match { expr :: BaseExpr a
          , cases :: [BaseCase a]
          }
  | If { ifCond :: BaseExpr a
       , ifBody :: [BaseStmt a]
       , ifElseBody :: [BaseStmt a]
       }
  | Call { callee :: BaseExpr a
         , constraintArgs :: [T.ConstraintArg]
         , typeArgs :: [Type]
         , args :: [BaseExpr a]
         }
  | BinOp { opConstraintArgs :: [T.ConstraintArg]
          , opTypeArgs :: [Type]
          , lhs :: BaseExpr a
          , op :: a
          , rhs :: BaseExpr a
          }
  | Record [(String, BaseExpr a)]
  | List (Maybe T.Type) [BaseExpr a]
  | FieldAccess (BaseExpr a) String
  | FnExpr (BaseFunction a)
  | Negate [T.ConstraintArg] (BaseExpr a)

  -- Expressions that can only be generated by the compiler
  | VoidExpr
  | TypeCall (BaseExpr a) [T.ConstraintArg]
  deriving (Show)

data BaseCase a = Case { pattern :: BasePattern a
                       , caseBody :: [BaseStmt a]
                       } deriving (Show)

data BasePattern a
  = PatDefault
  | PatLiteral Literal
  | PatVar String
  | PatRecord [(String, BasePattern a)]
  | PatList [BasePattern a] PatternRest
  | PatCtor a [BasePattern a]
  deriving (Show)

data PatternRest
  = NoRest
  | DiscardRest
  | NamedRest String
  deriving (Show)
