module Absyn.Base where

import Absyn.Meta
import Absyn.Type
import qualified Typing.Types as T

data BaseModule a = Module
  { imports :: [Import]
  , stmts :: [BaseStmt a]
  }

data BaseStmt a
  = Decl (BaseDecl a)
  | Expr (BaseExpr a)
  deriving (Show)

data BaseDecl a
  = FnStmt (BaseFunction a)
  | Enum a [Name] [BaseDataCtor a]
  | Let (Name, Type) (BaseExpr a)
  | Class { className :: a
          , classVars :: [BaseParam]
          , classMethods :: [BaseFunction a]
          }
  | Operator { opAssoc :: Associativity
             , opPrec :: Precedence
             , opGenerics :: BaseGenerics
             , opLhs :: BaseParam
             , opName :: a
             , opRhs :: BaseParam
             , opRetType :: Type
             , opBody :: [BaseStmt a]
             }
  | Interface { intfName :: a
              , intfParam :: Name
              , intfMethods :: [BaseInterfaceItem a]}
  | Implementation { implIntf :: a
                   , implGenerics :: BaseGenerics
                   , implType :: Type
                   , implMethods :: [BaseImplementationItem a]}
  | TypeAlias { aliasName :: Name
              , aliasVars :: [Name]
              , aliasType :: Type
              , resolvedType :: Maybe T.Type
              }
   deriving (Show)

data BaseInterfaceItem a
  = IntfVar (Name, Type)
  | IntfOperator { intfOpAssoc :: Associativity
                 , intfOpPrec :: Precedence
                 , intfOpLhs :: Type
                 , intfOpName :: a
                 , intfOpRhs :: Type
                 , intfOpRetType :: Type
                 }

  deriving (Show)

data BaseImplementationItem a
  = ImplVar (a, BaseExpr a)
  | ImplFunction { implName :: a
                 , implParams :: [Name]
                 , implBody :: [BaseStmt a]
                 }
  | ImplOperator { implOpLhs :: Name
                 , implOpName :: a
                 , implOpRhs :: Name
                 , implOpBody :: [BaseStmt a]
                 }
 deriving (Show)

type BaseDataCtor a = (a, Maybe [Type])
type BaseParam = (Name, Type)
type BaseGenerics = [(Name, [String])]

data BaseFunction a = Function
  { name :: a
  , generics :: BaseGenerics
  , params :: [BaseParam]
  , retType :: Type
  , body :: [BaseStmt a]
  } deriving (Show)

data BaseExpr a
  = Literal Literal
  | Ident [Name]
  | ParenthesizedExpr (BaseExpr a)
  | Match { expr :: BaseExpr a
          , cases :: [BaseCase a]
          }
  | If { ifCond :: BaseExpr a
       , ifBody :: [BaseStmt a]
       , ifElseBody :: [BaseStmt a]
       }
  | Call { callee :: BaseExpr a
         , constraintArgs :: [T.ConstraintArg]
         , typeArgs :: [Type]
         , args :: [BaseExpr a]
         }
  | BinOp { opConstraintArgs :: [T.ConstraintArg]
          , opTypeArgs :: [Type]
          , lhs :: BaseExpr a
          , op :: a
          , rhs :: BaseExpr a
          }
  | Record [(a, BaseExpr a)]
  | List (Maybe T.Type) [BaseExpr a]
  | FieldAccess (BaseExpr a) a
  | FnExpr (BaseFunction a)
  | Negate [T.ConstraintArg] (BaseExpr a)

  -- Expressions that can only be generated by the compiler
  | VoidExpr
  | TypeCall (BaseExpr a) [T.ConstraintArg]
  deriving (Show)

data BaseCase a = Case { pattern :: BasePattern a
                           , caseBody :: [BaseStmt a]
                           } deriving (Show)

data BasePattern a
  = PatDefault
  | PatLiteral Literal
  | PatVar a
  | PatRecord [(a, BasePattern a)]
  | PatList [BasePattern a] (BasePatternRest a)
  | PatCtor a [BasePattern a]
  deriving (Show)

data BasePatternRest a
  = NoRest
  | DiscardRest
  | NamedRest a
  deriving (Show)
